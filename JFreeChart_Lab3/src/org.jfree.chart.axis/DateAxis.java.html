<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>DateAxis.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">org.jfree.data (Mar 14, 2025 10:05:31â€¯p.m.)</a> &gt; <a href="../../index.html" class="el_group">JFreeChart_Lab3</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">org.jfree.chart.axis</a> &gt; <span class="el_source">DateAxis.java</span></div><h1>DateAxis.java</h1><pre class="source lang-java linenums">/* ===========================================================
 * JFreeChart : a free chart library for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2000-2014, by Object Refinery Limited and Contributors.
 *
 * Project Info:  http://www.jfree.org/jfreechart/index.html
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. 
 * Other names may be trademarks of their respective owners.]
 *
 * -------------
 * DateAxis.java
 * -------------
 * (C) Copyright 2000-2014, by Object Refinery Limited and Contributors.
 *
 * Original Author:  David Gilbert;
 * Contributor(s):   Jonathan Nash;
 *                   David Li;
 *                   Michael Rauch;
 *                   Bill Kelemen;
 *                   Pawel Pabis;
 *                   Chris Boek;
 *                   Peter Kolb (patches 1934255 and 2603321);
 *                   Andrew Mickish (patch 1870189);
 *                   Fawad Halim (bug 2201869);
 *
 * Changes (from 23-Jun-2001)
 * --------------------------
 * 23-Jun-2001 : Modified to work with null data source (DG);
 * 18-Sep-2001 : Updated header (DG);
 * 27-Nov-2001 : Changed constructors from public to protected, updated Javadoc
 *               comments (DG);
 * 16-Jan-2002 : Added an optional crosshair, based on the implementation by
 *               Jonathan Nash (DG);
 * 26-Feb-2002 : Updated import statements (DG);
 * 22-Apr-2002 : Added a setRange() method (DG);
 * 25-Jun-2002 : Removed redundant local variable (DG);
 * 25-Jul-2002 : Changed order of parameters in ValueAxis constructor (DG);
 * 21-Aug-2002 : The setTickUnit() method now turns off auto-tick unit
 *               selection (fix for bug id 528885) (DG);
 * 05-Sep-2002 : Updated the constructors to reflect changes in the Axis
 *               class (DG);
 * 18-Sep-2002 : Fixed errors reported by Checkstyle (DG);
 * 25-Sep-2002 : Added new setRange() methods, and deprecated
 *               setAxisRange() (DG);
 * 04-Oct-2002 : Changed auto tick selection to parallel number axis
 *               classes (DG);
 * 24-Oct-2002 : Added a date format override (DG);
 * 08-Nov-2002 : Moved to new package com.jrefinery.chart.axis (DG);
 * 14-Jan-2003 : Changed autoRangeMinimumSize from Number --&gt; double, moved
 *               crosshair settings to the plot (DG);
 * 15-Jan-2003 : Removed anchor date (DG);
 * 20-Jan-2003 : Removed unnecessary constructors (DG);
 * 26-Mar-2003 : Implemented Serializable (DG);
 * 02-May-2003 : Added additional units to createStandardDateTickUnits()
 *               method, as suggested by mhilpert in bug report 723187 (DG);
 * 13-May-2003 : Merged HorizontalDateAxis and VerticalDateAxis (DG);
 * 24-May-2003 : Added support for underlying timeline for
 *               SegmentedTimeline (BK);
 * 16-Jul-2003 : Applied patch from Pawel Pabis to fix overlapping dates (DG);
 * 22-Jul-2003 : Applied patch from Pawel Pabis for monthly ticks (DG);
 * 25-Jul-2003 : Fixed bug 777561 and 777586 (DG);
 * 13-Aug-2003 : Implemented Cloneable and added equals() method (DG);
 * 02-Sep-2003 : Fixes for bug report 790506 (DG);
 * 04-Sep-2003 : Fixed tick label alignment when axis appears at the top (DG);
 * 10-Sep-2003 : Fixes for segmented timeline (DG);
 * 17-Sep-2003 : Fixed a layout bug when multiple domain axes are used (DG);
 * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);
 * 07-Nov-2003 : Modified to use new tick classes (DG);
 * 12-Nov-2003 : Modified tick labelling to use roll unit from DateTickUnit
 *               when a calculated tick value is hidden (which can occur in
 *               segmented date axes) (DG);
 * 24-Nov-2003 : Fixed some problems with the auto tick unit selection, and
 *               fixed bug 846277 (labels missing for inverted axis) (DG);
 * 30-Dec-2003 : Fixed bug in refreshTicksHorizontal() when start of time unit
 *               (ex. 1st of month) was hidden, causing infinite loop (BK);
 * 13-Jan-2004 : Fixed bug in previousStandardDate() method (fix by Richard
 *               Wardle) (DG);
 * 21-Jan-2004 : Renamed translateJava2DToValue --&gt; java2DToValue, and
 *               translateValueToJava2D --&gt; valueToJava2D (DG);
 * 12-Mar-2004 : Fixed bug where date format override is ignored for vertical
 *               axis (DG);
 * 16-Mar-2004 : Added plotState to draw() method (DG);
 * 07-Apr-2004 : Changed string width calculation (DG);
 * 21-Apr-2004 : Fixed bug in estimateMaximumTickLabelWidth() method (bug id
 *               939148) (DG);
 * 11-Jan-2005 : Removed deprecated methods in preparation for 1.0.0
 *               release (DG);
 * 13-Jan-2005 : Fixed bug (see
 *               http://www.jfree.org/forum/viewtopic.php?t=11330) (DG);
 * 21-Apr-2005 : Replaced Insets with RectangleInsets, removed redundant
 *               argument from selectAutoTickUnit() (DG);
 * ------------- JFREECHART 1.0.x ---------------------------------------------
 * 10-Feb-2006 : Added some API doc comments in respect of bug 821046 (DG);
 * 19-Apr-2006 : Fixed bug 1472942 in equals() method (DG);
 * 25-Sep-2006 : Fixed bug 1564977 missing tick labels (DG);
 * 15-Jan-2007 : Added get/setTimeZone() suggested by 'skunk' (DG);
 * 18-Jan-2007 : Fixed bug 1638678, time zone for calendar in
 *               previousStandardDate() (DG);
 * 04-Apr-2007 : Use time zone in date calculations (CB);
 * 19-Apr-2007 : Fix exceptions in setMinimum/MaximumDate() (DG);
 * 03-May-2007 : Fixed minor bugs in previousStandardDate(), with new JUnit
 *               tests (DG);
 * 21-Nov-2007 : Fixed warnings from FindBugs (DG);
 * 01-Sep-2008 : Use new methods from DateRange, added fix for bug
 *               2078057 (DG);
 * 18-Sep-2008 : Added locale to go with timezone (DG);
 * 25-Sep-2008 : Added minor tick support, see patch 1934255 by Peter Kolb (DG);
 * 25-Nov-2008 : Added bug fix 2201869 by Fawad Halim (DG);
 * 21-Jan-2009 : Check tickUnit for minor tick count (DG);
 * 19-Mar-2009 : Added entity support - see patch 2603321 by Peter Kolb (DG);
 * 08-Feb-2012 : Bugfix for endless-loop, bug 3484403 by rbrabe (MH);
 * 25-Jul-2013 : Update event notification to use fireChangeEvent() (DG);
 * 01-Aug-2013 : Added attributedLabel override to support superscripts,
 *               subscripts and more (DG);
 * 12-Sep-2013 : Prevent exception when zooming in below 1 millisecond (DG);
 * 23-Nov-2013 : Deprecated DEFAULT_DATE_TICK_UNIT to fix bug #977 (DG);
 * 10-Mar-2014 : Add get/setLocale() methods (DG);
 * 
 */

package org.jfree.chart.axis;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.font.FontRenderContext;
import java.awt.font.LineMetrics;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;

import org.jfree.chart.event.AxisChangeEvent;
import org.jfree.chart.plot.Plot;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.ValueAxisPlot;
import org.jfree.chart.util.ParamChecks;
import org.jfree.data.Range;
import org.jfree.data.time.DateRange;
import org.jfree.data.time.Month;
import org.jfree.data.time.RegularTimePeriod;
import org.jfree.data.time.Year;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.TextAnchor;
import org.jfree.util.ObjectUtilities;

/**
 * The base class for axes that display dates.  You will find it easier to
 * understand how this axis works if you bear in mind that it really
 * displays/measures integer (or long) data, where the integers are
 * milliseconds since midnight, 1-Jan-1970.  When displaying tick labels, the
 * millisecond values are converted back to dates using a
 * &lt;code&gt;DateFormat&lt;/code&gt; instance.
 * &lt;P&gt;
 * You can also create a {@link org.jfree.chart.axis.Timeline} and supply in
 * the constructor to create an axis that only contains certain domain values.
 * For example, this allows you to create a date axis that only contains
 * working days.
 */
public class DateAxis extends ValueAxis implements Cloneable, Serializable {

    /** For serialization. */
    private static final long serialVersionUID = -1013460999649007604L;

    /** The default axis range. */
<span class="nc" id="L189">    public static final DateRange DEFAULT_DATE_RANGE = new DateRange();</span>

    /** The default minimum auto range size. */
    public static final double
            DEFAULT_AUTO_RANGE_MINIMUM_SIZE_IN_MILLISECONDS = 2.0;

    /** 
     * The default date tick unit.
     * 
     * @deprecated As pointed out in bug #977, the SimpleDateFormat in this
     *     object uses Calendar which is not thread safe...so you should 
     *     avoid reusing this instance and create a new instance as required.
     */
<span class="nc" id="L202">    public static final DateTickUnit DEFAULT_DATE_TICK_UNIT</span>
<span class="nc" id="L203">            = new DateTickUnit(DateTickUnitType.DAY, 1, new SimpleDateFormat());</span>

    /** The default anchor date. */
<span class="nc" id="L206">    public static final Date DEFAULT_ANCHOR_DATE = new Date();</span>

    /** The current tick unit. */
    private DateTickUnit tickUnit;

    /** The override date format. */
    private DateFormat dateFormatOverride;

    /**
     * Tick marks can be displayed at the start or the middle of the time
     * period.
     */
<span class="nc" id="L218">    private DateTickMarkPosition tickMarkPosition = DateTickMarkPosition.START;</span>

    /**
     * A timeline that includes all milliseconds (as defined by
     * &lt;code&gt;java.util.Date&lt;/code&gt;) in the real time line.
     */
    private static class DefaultTimeline implements Timeline, Serializable {

        /**
         * Converts a millisecond into a timeline value.
         *
         * @param millisecond  the millisecond.
         *
         * @return The timeline value.
         */
        @Override
        public long toTimelineValue(long millisecond) {
<span class="nc" id="L235">            return millisecond;</span>
        }

        /**
         * Converts a date into a timeline value.
         *
         * @param date  the domain value.
         *
         * @return The timeline value.
         */
        @Override
        public long toTimelineValue(Date date) {
<span class="nc" id="L247">            return date.getTime();</span>
        }

        /**
         * Converts a timeline value into a millisecond (as encoded by
         * &lt;code&gt;java.util.Date&lt;/code&gt;).
         *
         * @param value  the value.
         *
         * @return The millisecond.
         */
        @Override
        public long toMillisecond(long value) {
<span class="nc" id="L260">            return value;</span>
        }

        /**
         * Returns &lt;code&gt;true&lt;/code&gt; if the timeline includes the specified
         * domain value.
         *
         * @param millisecond  the millisecond.
         *
         * @return &lt;code&gt;true&lt;/code&gt;.
         */
        @Override
        public boolean containsDomainValue(long millisecond) {
<span class="nc" id="L273">            return true;</span>
        }

        /**
         * Returns &lt;code&gt;true&lt;/code&gt; if the timeline includes the specified
         * domain value.
         *
         * @param date  the date.
         *
         * @return &lt;code&gt;true&lt;/code&gt;.
         */
        @Override
        public boolean containsDomainValue(Date date) {
<span class="nc" id="L286">            return true;</span>
        }

        /**
         * Returns &lt;code&gt;true&lt;/code&gt; if the timeline includes the specified
         * domain value range.
         *
         * @param from  the start value.
         * @param to  the end value.
         *
         * @return &lt;code&gt;true&lt;/code&gt;.
         */
        @Override
        public boolean containsDomainRange(long from, long to) {
<span class="nc" id="L300">            return true;</span>
        }

        /**
         * Returns &lt;code&gt;true&lt;/code&gt; if the timeline includes the specified
         * domain value range.
         *
         * @param from  the start date.
         * @param to  the end date.
         *
         * @return &lt;code&gt;true&lt;/code&gt;.
         */
        @Override
        public boolean containsDomainRange(Date from, Date to) {
<span class="nc" id="L314">            return true;</span>
        }

        /**
         * Tests an object for equality with this instance.
         *
         * @param object  the object.
         *
         * @return A boolean.
         */
        @Override
        public boolean equals(Object object) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (object == null) {</span>
<span class="nc" id="L327">                return false;</span>
            }
<span class="nc bnc" id="L329" title="All 2 branches missed.">            if (object == this) {</span>
<span class="nc" id="L330">                return true;</span>
            }
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (object instanceof DefaultTimeline) {</span>
<span class="nc" id="L333">                return true;</span>
            }
<span class="nc" id="L335">            return false;</span>
        }
    }

    /** A static default timeline shared by all standard DateAxis */
<span class="nc" id="L340">    private static final Timeline DEFAULT_TIMELINE = new DefaultTimeline();</span>

    /** The time zone for the axis. */
    private TimeZone timeZone;

    /**
     * The locale for the axis (&lt;code&gt;null&lt;/code&gt; is not permitted).
     *
     * @since 1.0.11
     */
    private Locale locale;

    /** Our underlying timeline. */
    private Timeline timeline;

    /**
     * Creates a date axis with no label.
     */
    public DateAxis() {
<span class="nc" id="L359">        this(null);</span>
<span class="nc" id="L360">    }</span>

    /**
     * Creates a date axis with the specified label.
     *
     * @param label  the axis label (&lt;code&gt;null&lt;/code&gt; permitted).
     */
    public DateAxis(String label) {
<span class="nc" id="L368">        this(label, TimeZone.getDefault());</span>
<span class="nc" id="L369">    }</span>

    /**
     * Creates a date axis. A timeline is specified for the axis. This allows
     * special transformations to occur between a domain of values and the
     * values included in the axis.
     *
     * @see org.jfree.chart.axis.SegmentedTimeline
     *
     * @param label  the axis label (&lt;code&gt;null&lt;/code&gt; permitted).
     * @param zone  the time zone.
     *
     * @deprecated From 1.0.11 onwards, use {@link #DateAxis(String, TimeZone,
     *         Locale)} instead, to explicitly set the locale.
     */
    public DateAxis(String label, TimeZone zone) {
<span class="nc" id="L385">        this(label, zone, Locale.getDefault());</span>
<span class="nc" id="L386">    }</span>

    /**
     * Creates a date axis. A timeline is specified for the axis. This allows
     * special transformations to occur between a domain of values and the
     * values included in the axis.
     *
     * @see org.jfree.chart.axis.SegmentedTimeline
     *
     * @param label  the axis label (&lt;code&gt;null&lt;/code&gt; permitted).
     * @param zone  the time zone.
     * @param locale  the locale (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @since 1.0.11
     */
    public DateAxis(String label, TimeZone zone, Locale locale) {
<span class="nc" id="L402">        super(label, DateAxis.createStandardDateTickUnits(zone, locale));</span>
<span class="nc" id="L403">        this.tickUnit = new DateTickUnit(DateTickUnitType.DAY, 1, </span>
<span class="nc" id="L404">                new SimpleDateFormat());</span>
<span class="nc" id="L405">        setAutoRangeMinimumSize(</span>
<span class="nc" id="L406">                DEFAULT_AUTO_RANGE_MINIMUM_SIZE_IN_MILLISECONDS);</span>
<span class="nc" id="L407">        setRange(DEFAULT_DATE_RANGE, false, false);</span>
<span class="nc" id="L408">        this.dateFormatOverride = null;</span>
<span class="nc" id="L409">        this.timeZone = zone;</span>
<span class="nc" id="L410">        this.locale = locale;</span>
<span class="nc" id="L411">        this.timeline = DEFAULT_TIMELINE;</span>
<span class="nc" id="L412">    }</span>

    /**
     * Returns the time zone for the axis.
     *
     * @return The time zone (never &lt;code&gt;null&lt;/code&gt;).
     *
     * @since 1.0.4
     *
     * @see #setTimeZone(TimeZone)
     */
    public TimeZone getTimeZone() {
<span class="nc" id="L424">        return this.timeZone;</span>
    }

    /**
     * Sets the time zone for the axis and sends an {@link AxisChangeEvent} to
     * all registered listeners.
     *
     * @param zone  the time zone (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @since 1.0.4
     *
     * @see #getTimeZone()
     */
    public void setTimeZone(TimeZone zone) {
<span class="nc" id="L438">        ParamChecks.nullNotPermitted(zone, &quot;zone&quot;);</span>
<span class="nc" id="L439">        this.timeZone = zone;</span>
<span class="nc" id="L440">        setStandardTickUnits(createStandardDateTickUnits(zone, this.locale));</span>
<span class="nc" id="L441">        fireChangeEvent();</span>
<span class="nc" id="L442">    }</span>
    
    /**
     * Returns the locale for this axis.
     * 
     * @return The locale (never &lt;code&gt;null&lt;/code&gt;).
     * 
     * @since 1.0.18
     */
    public Locale getLocale() {
<span class="nc" id="L452">        return this.locale;</span>
    }
    
    /**
     * Sets the locale for the axis and sends a change event to all registered 
     * listeners.
     * 
     * @param locale  the new locale (&lt;code&gt;null&lt;/code&gt; not permitted).
     */
    public void setLocale(Locale locale) {
<span class="nc" id="L462">        ParamChecks.nullNotPermitted(locale, &quot;locale&quot;);</span>
<span class="nc" id="L463">        this.locale = locale;</span>
<span class="nc" id="L464">        setStandardTickUnits(createStandardDateTickUnits(this.timeZone, </span>
<span class="nc" id="L465">                this.locale));</span>
<span class="nc" id="L466">        fireChangeEvent();</span>
<span class="nc" id="L467">    }</span>

    /**
     * Returns the underlying timeline used by this axis.
     *
     * @return The timeline.
     */
    public Timeline getTimeline() {
<span class="nc" id="L475">        return this.timeline;</span>
    }

    /**
     * Sets the underlying timeline to use for this axis.  If the timeline is 
     * changed, an {@link AxisChangeEvent} is sent to all registered listeners.
     *
     * @param timeline  the timeline.
     */
    public void setTimeline(Timeline timeline) {
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (this.timeline != timeline) {</span>
<span class="nc" id="L486">            this.timeline = timeline;</span>
<span class="nc" id="L487">            fireChangeEvent();</span>
        }
<span class="nc" id="L489">    }</span>

    /**
     * Returns the tick unit for the axis.
     * &lt;p&gt;
     * Note: if the &lt;code&gt;autoTickUnitSelection&lt;/code&gt; flag is
     * &lt;code&gt;true&lt;/code&gt; the tick unit may be changed while the axis is being
     * drawn, so in that case the return value from this method may be
     * irrelevant if the method is called before the axis has been drawn.
     *
     * @return The tick unit (possibly &lt;code&gt;null&lt;/code&gt;).
     *
     * @see #setTickUnit(DateTickUnit)
     * @see ValueAxis#isAutoTickUnitSelection()
     */
    public DateTickUnit getTickUnit() {
<span class="nc" id="L505">        return this.tickUnit;</span>
    }

    /**
     * Sets the tick unit for the axis.  The auto-tick-unit-selection flag is
     * set to &lt;code&gt;false&lt;/code&gt;, and registered listeners are notified that
     * the axis has been changed.
     *
     * @param unit  the tick unit.
     *
     * @see #getTickUnit()
     * @see #setTickUnit(DateTickUnit, boolean, boolean)
     */
    public void setTickUnit(DateTickUnit unit) {
<span class="nc" id="L519">        setTickUnit(unit, true, true);</span>
<span class="nc" id="L520">    }</span>

    /**
     * Sets the tick unit attribute and, if requested, sends an 
     * {@link AxisChangeEvent} to all registered listeners.
     *
     * @param unit  the new tick unit.
     * @param notify  notify registered listeners?
     * @param turnOffAutoSelection  turn off auto selection?
     *
     * @see #getTickUnit()
     */
    public void setTickUnit(DateTickUnit unit, boolean notify,
                            boolean turnOffAutoSelection) {

<span class="nc" id="L535">        this.tickUnit = unit;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (turnOffAutoSelection) {</span>
<span class="nc" id="L537">            setAutoTickUnitSelection(false, false);</span>
        }
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (notify) {</span>
<span class="nc" id="L540">            fireChangeEvent();</span>
        }

<span class="nc" id="L543">    }</span>

    /**
     * Returns the date format override.  If this is non-null, then it will be
     * used to format the dates on the axis.
     *
     * @return The formatter (possibly &lt;code&gt;null&lt;/code&gt;).
     */
    public DateFormat getDateFormatOverride() {
<span class="nc" id="L552">        return this.dateFormatOverride;</span>
    }

    /**
     * Sets the date format override and sends an {@link AxisChangeEvent} to 
     * all registered listeners.  If this is non-null, then it will be
     * used to format the dates on the axis.
     *
     * @param formatter  the date formatter (&lt;code&gt;null&lt;/code&gt; permitted).
     */
    public void setDateFormatOverride(DateFormat formatter) {
<span class="nc" id="L563">        this.dateFormatOverride = formatter;</span>
<span class="nc" id="L564">        fireChangeEvent();</span>
<span class="nc" id="L565">    }</span>

    /**
     * Sets the upper and lower bounds for the axis and sends an
     * {@link AxisChangeEvent} to all registered listeners.  As a side-effect,
     * the auto-range flag is set to false.
     *
     * @param range  the new range (&lt;code&gt;null&lt;/code&gt; not permitted).
     */
    @Override
    public void setRange(Range range) {
<span class="nc" id="L576">        setRange(range, true, true);</span>
<span class="nc" id="L577">    }</span>

    /**
     * Sets the range for the axis, if requested, sends an
     * {@link AxisChangeEvent} to all registered listeners.  As a side-effect,
     * the auto-range flag is set to &lt;code&gt;false&lt;/code&gt; (optional).
     *
     * @param range  the range (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param turnOffAutoRange  a flag that controls whether or not the auto
     *                          range is turned off.
     * @param notify  a flag that controls whether or not listeners are
     *                notified.
     */
    @Override
    public void setRange(Range range, boolean turnOffAutoRange,
                         boolean notify) {
<span class="nc" id="L593">        ParamChecks.nullNotPermitted(range, &quot;range&quot;);</span>
        // usually the range will be a DateRange, but if it isn't do a
        // conversion...
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (!(range instanceof DateRange)) {</span>
<span class="nc" id="L597">            range = new DateRange(range);</span>
        }
<span class="nc" id="L599">        super.setRange(range, turnOffAutoRange, notify);</span>
<span class="nc" id="L600">    }</span>

    /**
     * Sets the axis range and sends an {@link AxisChangeEvent} to all
     * registered listeners.
     *
     * @param lower  the lower bound for the axis.
     * @param upper  the upper bound for the axis.
     */
    public void setRange(Date lower, Date upper) {
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (lower.getTime() &gt;= upper.getTime()) {</span>
<span class="nc" id="L611">            throw new IllegalArgumentException(&quot;Requires 'lower' &lt; 'upper'.&quot;);</span>
        }
<span class="nc" id="L613">        setRange(new DateRange(lower, upper));</span>
<span class="nc" id="L614">    }</span>

    /**
     * Sets the axis range and sends an {@link AxisChangeEvent} to all
     * registered listeners.
     *
     * @param lower  the lower bound for the axis.
     * @param upper  the upper bound for the axis.
     */
    @Override
    public void setRange(double lower, double upper) {
<span class="nc bnc" id="L625" title="All 2 branches missed.">        if (lower &gt;= upper) {</span>
<span class="nc" id="L626">            throw new IllegalArgumentException(&quot;Requires 'lower' &lt; 'upper'.&quot;);</span>
        }
<span class="nc" id="L628">        setRange(new DateRange(lower, upper));</span>
<span class="nc" id="L629">    }</span>

    /**
     * Returns the earliest date visible on the axis.
     *
     * @return The date.
     *
     * @see #setMinimumDate(Date)
     * @see #getMaximumDate()
     */
    public Date getMinimumDate() {
        Date result;
<span class="nc" id="L641">        Range range = getRange();</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (range instanceof DateRange) {</span>
<span class="nc" id="L643">            DateRange r = (DateRange) range;</span>
<span class="nc" id="L644">            result = r.getLowerDate();</span>
<span class="nc" id="L645">        }</span>
        else {
<span class="nc" id="L647">            result = new Date((long) range.getLowerBound());</span>
        }
<span class="nc" id="L649">        return result;</span>
    }

    /**
     * Sets the minimum date visible on the axis and sends an
     * {@link AxisChangeEvent} to all registered listeners.  If
     * &lt;code&gt;date&lt;/code&gt; is on or after the current maximum date for
     * the axis, the maximum date will be shifted to preserve the current
     * length of the axis.
     *
     * @param date  the date (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @see #getMinimumDate()
     * @see #setMaximumDate(Date)
     */
    public void setMinimumDate(Date date) {
<span class="nc" id="L665">        ParamChecks.nullNotPermitted(date, &quot;date&quot;);</span>
        // check the new minimum date relative to the current maximum date
<span class="nc" id="L667">        Date maxDate = getMaximumDate();</span>
<span class="nc" id="L668">        long maxMillis = maxDate.getTime();</span>
<span class="nc" id="L669">        long newMinMillis = date.getTime();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        if (maxMillis &lt;= newMinMillis) {</span>
<span class="nc" id="L671">            Date oldMin = getMinimumDate();</span>
<span class="nc" id="L672">            long length = maxMillis - oldMin.getTime();</span>
<span class="nc" id="L673">            maxDate = new Date(newMinMillis + length);</span>
        }
<span class="nc" id="L675">        setRange(new DateRange(date, maxDate), true, false);</span>
<span class="nc" id="L676">        fireChangeEvent();</span>
<span class="nc" id="L677">    }</span>

    /**
     * Returns the latest date visible on the axis.
     *
     * @return The date.
     *
     * @see #setMaximumDate(Date)
     * @see #getMinimumDate()
     */
    public Date getMaximumDate() {
        Date result;
<span class="nc" id="L689">        Range range = getRange();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (range instanceof DateRange) {</span>
<span class="nc" id="L691">            DateRange r = (DateRange) range;</span>
<span class="nc" id="L692">            result = r.getUpperDate();</span>
<span class="nc" id="L693">        }</span>
        else {
<span class="nc" id="L695">            result = new Date((long) range.getUpperBound());</span>
        }
<span class="nc" id="L697">        return result;</span>
    }

    /**
     * Sets the maximum date visible on the axis and sends an
     * {@link AxisChangeEvent} to all registered listeners.  If
     * &lt;code&gt;maximumDate&lt;/code&gt; is on or before the current minimum date for
     * the axis, the minimum date will be shifted to preserve the current
     * length of the axis.
     *
     * @param maximumDate  the date (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @see #getMinimumDate()
     * @see #setMinimumDate(Date)
     */
    public void setMaximumDate(Date maximumDate) {
<span class="nc" id="L713">        ParamChecks.nullNotPermitted(maximumDate, &quot;maximumDate&quot;);</span>
        // check the new maximum date relative to the current minimum date
<span class="nc" id="L715">        Date minDate = getMinimumDate();</span>
<span class="nc" id="L716">        long minMillis = minDate.getTime();</span>
<span class="nc" id="L717">        long newMaxMillis = maximumDate.getTime();</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (minMillis &gt;= newMaxMillis) {</span>
<span class="nc" id="L719">            Date oldMax = getMaximumDate();</span>
<span class="nc" id="L720">            long length = oldMax.getTime() - minMillis;</span>
<span class="nc" id="L721">            minDate = new Date(newMaxMillis - length);</span>
        }
<span class="nc" id="L723">        setRange(new DateRange(minDate, maximumDate), true, false);</span>
<span class="nc" id="L724">        fireChangeEvent();</span>
<span class="nc" id="L725">    }</span>

    /**
     * Returns the tick mark position (start, middle or end of the time period).
     *
     * @return The position (never &lt;code&gt;null&lt;/code&gt;).
     */
    public DateTickMarkPosition getTickMarkPosition() {
<span class="nc" id="L733">        return this.tickMarkPosition;</span>
    }

    /**
     * Sets the tick mark position (start, middle or end of the time period)
     * and sends an {@link AxisChangeEvent} to all registered listeners.
     *
     * @param position  the position (&lt;code&gt;null&lt;/code&gt; not permitted).
     */
    public void setTickMarkPosition(DateTickMarkPosition position) {
<span class="nc" id="L743">        ParamChecks.nullNotPermitted(position, &quot;position&quot;);</span>
<span class="nc" id="L744">        this.tickMarkPosition = position;</span>
<span class="nc" id="L745">        fireChangeEvent();</span>
<span class="nc" id="L746">    }</span>

    /**
     * Configures the axis to work with the specified plot.  If the axis has
     * auto-scaling, then sets the maximum and minimum values.
     */
    @Override
    public void configure() {
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (isAutoRange()) {</span>
<span class="nc" id="L755">            autoAdjustRange();</span>
        }
<span class="nc" id="L757">    }</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the axis hides this value, and
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @param millis  the data value.
     *
     * @return A value.
     */
    public boolean isHiddenValue(long millis) {
<span class="nc bnc" id="L768" title="All 2 branches missed.">        return (!this.timeline.containsDomainValue(new Date(millis)));</span>
    }

    /**
     * Translates the data value to the display coordinates (Java 2D User Space)
     * of the chart.
     *
     * @param value  the date to be plotted.
     * @param area  the rectangle (in Java2D space) where the data is to be
     *              plotted.
     * @param edge  the axis location.
     *
     * @return The coordinate corresponding to the supplied data value.
     */
    @Override
    public double valueToJava2D(double value, Rectangle2D area,
            RectangleEdge edge) {

<span class="nc" id="L786">        value = this.timeline.toTimelineValue((long) value);</span>

<span class="nc" id="L788">        DateRange range = (DateRange) getRange();</span>
<span class="nc" id="L789">        double axisMin = this.timeline.toTimelineValue(range.getLowerMillis());</span>
<span class="nc" id="L790">        double axisMax = this.timeline.toTimelineValue(range.getUpperMillis());</span>
<span class="nc" id="L791">        double result = 0.0;</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="nc" id="L793">            double minX = area.getX();</span>
<span class="nc" id="L794">            double maxX = area.getMaxX();</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (isInverted()) {</span>
<span class="nc" id="L796">                result = maxX + ((value - axisMin) / (axisMax - axisMin))</span>
<span class="nc" id="L797">                         * (minX - maxX);</span>
<span class="nc" id="L798">            }</span>
            else {
<span class="nc" id="L800">                result = minX + ((value - axisMin) / (axisMax - axisMin))</span>
<span class="nc" id="L801">                         * (maxX - minX);</span>
            }
<span class="nc" id="L803">        }</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L805">            double minY = area.getMinY();</span>
<span class="nc" id="L806">            double maxY = area.getMaxY();</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if (isInverted()) {</span>
<span class="nc" id="L808">                result = minY + (((value - axisMin) / (axisMax - axisMin))</span>
<span class="nc" id="L809">                         * (maxY - minY));</span>
<span class="nc" id="L810">            }</span>
            else {
<span class="nc" id="L812">                result = maxY - (((value - axisMin) / (axisMax - axisMin))</span>
<span class="nc" id="L813">                         * (maxY - minY));</span>
            }
        }
<span class="nc" id="L816">        return result;</span>
    }

    /**
     * Translates a date to Java2D coordinates, based on the range displayed by
     * this axis for the specified data area.
     *
     * @param date  the date.
     * @param area  the rectangle (in Java2D space) where the data is to be
     *              plotted.
     * @param edge  the axis location.
     *
     * @return The coordinate corresponding to the supplied date.
     */
    public double dateToJava2D(Date date, Rectangle2D area, 
            RectangleEdge edge) {
<span class="nc" id="L832">        double value = date.getTime();</span>
<span class="nc" id="L833">        return valueToJava2D(value, area, edge);</span>
    }

    /**
     * Translates a Java2D coordinate into the corresponding data value.  To
     * perform this translation, you need to know the area used for plotting
     * data, and which edge the axis is located on.
     *
     * @param java2DValue  the coordinate in Java2D space.
     * @param area  the rectangle (in Java2D space) where the data is to be
     *              plotted.
     * @param edge  the axis location.
     *
     * @return A data value.
     */
    @Override
    public double java2DToValue(double java2DValue, Rectangle2D area, 
            RectangleEdge edge) {

<span class="nc" id="L852">        DateRange range = (DateRange) getRange();</span>
<span class="nc" id="L853">        double axisMin = this.timeline.toTimelineValue(range.getLowerMillis());</span>
<span class="nc" id="L854">        double axisMax = this.timeline.toTimelineValue(range.getUpperMillis());</span>

<span class="nc" id="L856">        double min = 0.0;</span>
<span class="nc" id="L857">        double max = 0.0;</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="nc" id="L859">            min = area.getX();</span>
<span class="nc" id="L860">            max = area.getMaxX();</span>
<span class="nc" id="L861">        }</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L863">            min = area.getMaxY();</span>
<span class="nc" id="L864">            max = area.getY();</span>
        }

        double result;
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (isInverted()) {</span>
<span class="nc" id="L869">             result = axisMax - ((java2DValue - min) / (max - min)</span>
<span class="nc" id="L870">                      * (axisMax - axisMin));</span>
<span class="nc" id="L871">        }</span>
        else {
<span class="nc" id="L873">             result = axisMin + ((java2DValue - min) / (max - min)</span>
<span class="nc" id="L874">                      * (axisMax - axisMin));</span>
        }

<span class="nc" id="L877">        return this.timeline.toMillisecond((long) result);</span>
    }

    /**
     * Calculates the value of the lowest visible tick on the axis.
     *
     * @param unit  date unit to use.
     *
     * @return The value of the lowest visible tick on the axis.
     */
    public Date calculateLowestVisibleTickValue(DateTickUnit unit) {
<span class="nc" id="L888">        return nextStandardDate(getMinimumDate(), unit);</span>
    }

    /**
     * Calculates the value of the highest visible tick on the axis.
     *
     * @param unit  date unit to use.
     *
     * @return The value of the highest visible tick on the axis.
     */
    public Date calculateHighestVisibleTickValue(DateTickUnit unit) {
<span class="nc" id="L899">        return previousStandardDate(getMaximumDate(), unit);</span>
    }

    /**
     * Returns the previous &quot;standard&quot; date, for a given date and tick unit.
     *
     * @param date  the reference date.
     * @param unit  the tick unit.
     *
     * @return The previous &quot;standard&quot; date.
     */
    protected Date previousStandardDate(Date date, DateTickUnit unit) {

        int milliseconds;
        int seconds;
        int minutes;
        int hours;
        int days;
        int months;
        int years;

<span class="nc" id="L920">        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);</span>
<span class="nc" id="L921">        calendar.setTime(date);</span>
<span class="nc" id="L922">        int count = unit.getCount();</span>
<span class="nc" id="L923">        int current = calendar.get(unit.getCalendarField());</span>
<span class="nc" id="L924">        int value = count * (current / count);</span>

<span class="nc bnc" id="L926" title="All 8 branches missed.">        switch (unit.getUnit()) {</span>

            case DateTickUnit.MILLISECOND :
<span class="nc" id="L929">                years = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L930">                months = calendar.get(Calendar.MONTH);</span>
<span class="nc" id="L931">                days = calendar.get(Calendar.DATE);</span>
<span class="nc" id="L932">                hours = calendar.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L933">                minutes = calendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L934">                seconds = calendar.get(Calendar.SECOND);</span>
<span class="nc" id="L935">                calendar.set(years, months, days, hours, minutes, seconds);</span>
<span class="nc" id="L936">                calendar.set(Calendar.MILLISECOND, value);</span>
<span class="nc" id="L937">                Date mm = calendar.getTime();</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">                if (mm.getTime() &gt;= date.getTime()) {</span>
<span class="nc" id="L939">                    calendar.set(Calendar.MILLISECOND, value - 1);</span>
<span class="nc" id="L940">                    mm = calendar.getTime();</span>
                }
<span class="nc" id="L942">                return mm;</span>

            case DateTickUnit.SECOND :
<span class="nc" id="L945">                years = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L946">                months = calendar.get(Calendar.MONTH);</span>
<span class="nc" id="L947">                days = calendar.get(Calendar.DATE);</span>
<span class="nc" id="L948">                hours = calendar.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L949">                minutes = calendar.get(Calendar.MINUTE);</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">                if (this.tickMarkPosition == DateTickMarkPosition.START) {</span>
<span class="nc" id="L951">                    milliseconds = 0;</span>
<span class="nc" id="L952">                }</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">                else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {</span>
<span class="nc" id="L954">                    milliseconds = 500;</span>
<span class="nc" id="L955">                }</span>
                else {
<span class="nc" id="L957">                    milliseconds = 999;</span>
                }
<span class="nc" id="L959">                calendar.set(Calendar.MILLISECOND, milliseconds);</span>
<span class="nc" id="L960">                calendar.set(years, months, days, hours, minutes, value);</span>
<span class="nc" id="L961">                Date dd = calendar.getTime();</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (dd.getTime() &gt;= date.getTime()) {</span>
<span class="nc" id="L963">                    calendar.set(Calendar.SECOND, value - 1);</span>
<span class="nc" id="L964">                    dd = calendar.getTime();</span>
                }
<span class="nc" id="L966">                return dd;</span>

            case DateTickUnit.MINUTE :
<span class="nc" id="L969">                years = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L970">                months = calendar.get(Calendar.MONTH);</span>
<span class="nc" id="L971">                days = calendar.get(Calendar.DATE);</span>
<span class="nc" id="L972">                hours = calendar.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">                if (this.tickMarkPosition == DateTickMarkPosition.START) {</span>
<span class="nc" id="L974">                    seconds = 0;</span>
<span class="nc" id="L975">                }</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {</span>
<span class="nc" id="L977">                    seconds = 30;</span>
<span class="nc" id="L978">                }</span>
                else {
<span class="nc" id="L980">                    seconds = 59;</span>
                }
<span class="nc" id="L982">                calendar.clear(Calendar.MILLISECOND);</span>
<span class="nc" id="L983">                calendar.set(years, months, days, hours, value, seconds);</span>
<span class="nc" id="L984">                Date d0 = calendar.getTime();</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">                if (d0.getTime() &gt;= date.getTime()) {</span>
<span class="nc" id="L986">                    calendar.set(Calendar.MINUTE, value - 1);</span>
<span class="nc" id="L987">                    d0 = calendar.getTime();</span>
                }
<span class="nc" id="L989">                return d0;</span>

            case DateTickUnit.HOUR :
<span class="nc" id="L992">                years = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L993">                months = calendar.get(Calendar.MONTH);</span>
<span class="nc" id="L994">                days = calendar.get(Calendar.DATE);</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">                if (this.tickMarkPosition == DateTickMarkPosition.START) {</span>
<span class="nc" id="L996">                    minutes = 0;</span>
<span class="nc" id="L997">                    seconds = 0;</span>
<span class="nc" id="L998">                }</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {</span>
<span class="nc" id="L1000">                    minutes = 30;</span>
<span class="nc" id="L1001">                    seconds = 0;</span>
<span class="nc" id="L1002">                }</span>
                else {
<span class="nc" id="L1004">                    minutes = 59;</span>
<span class="nc" id="L1005">                    seconds = 59;</span>
                }
<span class="nc" id="L1007">                calendar.clear(Calendar.MILLISECOND);</span>
<span class="nc" id="L1008">                calendar.set(years, months, days, value, minutes, seconds);</span>
<span class="nc" id="L1009">                Date d1 = calendar.getTime();</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">                if (d1.getTime() &gt;= date.getTime()) {</span>
<span class="nc" id="L1011">                    calendar.set(Calendar.HOUR_OF_DAY, value - 1);</span>
<span class="nc" id="L1012">                    d1 = calendar.getTime();</span>
                }
<span class="nc" id="L1014">                return d1;</span>

            case DateTickUnit.DAY :
<span class="nc" id="L1017">                years = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L1018">                months = calendar.get(Calendar.MONTH);</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                if (this.tickMarkPosition == DateTickMarkPosition.START) {</span>
<span class="nc" id="L1020">                    hours = 0;</span>
<span class="nc" id="L1021">                }</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {</span>
<span class="nc" id="L1023">                    hours = 12;</span>
<span class="nc" id="L1024">                }</span>
                else {
<span class="nc" id="L1026">                    hours = 23;</span>
                }
<span class="nc" id="L1028">                calendar.clear(Calendar.MILLISECOND);</span>
<span class="nc" id="L1029">                calendar.set(years, months, value, hours, 0, 0);</span>
                // long result = calendar.getTimeInMillis();
                    // won't work with JDK 1.3
<span class="nc" id="L1032">                Date d2 = calendar.getTime();</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                if (d2.getTime() &gt;= date.getTime()) {</span>
<span class="nc" id="L1034">                    calendar.set(Calendar.DATE, value - 1);</span>
<span class="nc" id="L1035">                    d2 = calendar.getTime();</span>
                }
<span class="nc" id="L1037">                return d2;</span>

            case DateTickUnit.MONTH :
<span class="nc" id="L1040">                years = calendar.get(Calendar.YEAR);</span>
<span class="nc" id="L1041">                calendar.clear(Calendar.MILLISECOND);</span>
<span class="nc" id="L1042">                calendar.set(years, value, 1, 0, 0, 0);</span>
<span class="nc" id="L1043">                Month month = new Month(calendar.getTime(), this.timeZone,</span>
<span class="nc" id="L1044">                        this.locale);</span>
<span class="nc" id="L1045">                Date standardDate = calculateDateForPosition(</span>
<span class="nc" id="L1046">                        month, this.tickMarkPosition);</span>
<span class="nc" id="L1047">                long millis = standardDate.getTime();</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                if (millis &gt;= date.getTime()) {</span>
<span class="nc" id="L1049">                    month = (Month) month.previous();</span>
                    // need to peg the month in case the time zone isn't the
                    // default - see bug 2078057
<span class="nc" id="L1052">                    month.peg(Calendar.getInstance(this.timeZone));</span>
<span class="nc" id="L1053">                    standardDate = calculateDateForPosition(</span>
<span class="nc" id="L1054">                            month, this.tickMarkPosition);</span>
                }
<span class="nc" id="L1056">                return standardDate;</span>

            case DateTickUnit.YEAR :
<span class="nc bnc" id="L1059" title="All 2 branches missed.">                if (this.tickMarkPosition == DateTickMarkPosition.START) {</span>
<span class="nc" id="L1060">                    months = 0;</span>
<span class="nc" id="L1061">                    days = 1;</span>
<span class="nc" id="L1062">                }</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {</span>
<span class="nc" id="L1064">                    months = 6;</span>
<span class="nc" id="L1065">                    days = 1;</span>
<span class="nc" id="L1066">                }</span>
                else {
<span class="nc" id="L1068">                    months = 11;</span>
<span class="nc" id="L1069">                    days = 31;</span>
                }
<span class="nc" id="L1071">                calendar.clear(Calendar.MILLISECOND);</span>
<span class="nc" id="L1072">                calendar.set(value, months, days, 0, 0, 0);</span>
<span class="nc" id="L1073">                Date d3 = calendar.getTime();</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                if (d3.getTime() &gt;= date.getTime()) {</span>
<span class="nc" id="L1075">                    calendar.set(Calendar.YEAR, value - 1);</span>
<span class="nc" id="L1076">                    d3 = calendar.getTime();</span>
                }
<span class="nc" id="L1078">                return d3;</span>

<span class="nc" id="L1080">            default: return null;</span>

        }

    }

    /**
     * Returns a {@link java.util.Date} corresponding to the specified position
     * within a {@link RegularTimePeriod}.
     *
     * @param period  the period.
     * @param position  the position (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return A date.
     */
    private Date calculateDateForPosition(RegularTimePeriod period,
            DateTickMarkPosition position) {
<span class="nc" id="L1097">        ParamChecks.nullNotPermitted(period, &quot;period&quot;);</span>
<span class="nc" id="L1098">        Date result = null;</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        if (position == DateTickMarkPosition.START) {</span>
<span class="nc" id="L1100">            result = new Date(period.getFirstMillisecond());</span>
<span class="nc" id="L1101">        }</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        else if (position == DateTickMarkPosition.MIDDLE) {</span>
<span class="nc" id="L1103">            result = new Date(period.getMiddleMillisecond());</span>
<span class="nc" id="L1104">        }</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        else if (position == DateTickMarkPosition.END) {</span>
<span class="nc" id="L1106">            result = new Date(period.getLastMillisecond());</span>
        }
<span class="nc" id="L1108">        return result;</span>

    }

    /**
     * Returns the first &quot;standard&quot; date (based on the specified field and
     * units).
     *
     * @param date  the reference date.
     * @param unit  the date tick unit.
     *
     * @return The next &quot;standard&quot; date.
     */
    protected Date nextStandardDate(Date date, DateTickUnit unit) {
<span class="nc" id="L1122">        Date previous = previousStandardDate(date, unit);</span>
<span class="nc" id="L1123">        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);</span>
<span class="nc" id="L1124">        calendar.setTime(previous);</span>
<span class="nc" id="L1125">        calendar.add(unit.getCalendarField(), unit.getMultiple());</span>
<span class="nc" id="L1126">        return calendar.getTime();</span>
    }

    /**
     * Returns a collection of standard date tick units that uses the default
     * time zone.  This collection will be used by default, but you are free
     * to create your own collection if you want to (see the
     * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited
     * from the {@link ValueAxis} class).
     *
     * @return A collection of standard date tick units.
     */
    public static TickUnitSource createStandardDateTickUnits() {
<span class="nc" id="L1139">        return createStandardDateTickUnits(TimeZone.getDefault(),</span>
<span class="nc" id="L1140">                Locale.getDefault());</span>
    }

    /**
     * Returns a collection of standard date tick units.  This collection will
     * be used by default, but you are free to create your own collection if
     * you want to (see the
     * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited
     * from the {@link ValueAxis} class).
     *
     * @param zone  the time zone (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param locale  the locale (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return A collection of standard date tick units.
     *
     * @since 1.0.11
     */
    public static TickUnitSource createStandardDateTickUnits(TimeZone zone,
            Locale locale) {

<span class="nc" id="L1160">        ParamChecks.nullNotPermitted(zone, &quot;zone&quot;);</span>
<span class="nc" id="L1161">        ParamChecks.nullNotPermitted(locale, &quot;locale&quot;);</span>
<span class="nc" id="L1162">        TickUnits units = new TickUnits();</span>

        // date formatters
<span class="nc" id="L1165">        DateFormat f1 = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;, locale);</span>
<span class="nc" id="L1166">        DateFormat f2 = new SimpleDateFormat(&quot;HH:mm:ss&quot;, locale);</span>
<span class="nc" id="L1167">        DateFormat f3 = new SimpleDateFormat(&quot;HH:mm&quot;, locale);</span>
<span class="nc" id="L1168">        DateFormat f4 = new SimpleDateFormat(&quot;d-MMM, HH:mm&quot;, locale);</span>
<span class="nc" id="L1169">        DateFormat f5 = new SimpleDateFormat(&quot;d-MMM&quot;, locale);</span>
<span class="nc" id="L1170">        DateFormat f6 = new SimpleDateFormat(&quot;MMM-yyyy&quot;, locale);</span>
<span class="nc" id="L1171">        DateFormat f7 = new SimpleDateFormat(&quot;yyyy&quot;, locale);</span>

<span class="nc" id="L1173">        f1.setTimeZone(zone);</span>
<span class="nc" id="L1174">        f2.setTimeZone(zone);</span>
<span class="nc" id="L1175">        f3.setTimeZone(zone);</span>
<span class="nc" id="L1176">        f4.setTimeZone(zone);</span>
<span class="nc" id="L1177">        f5.setTimeZone(zone);</span>
<span class="nc" id="L1178">        f6.setTimeZone(zone);</span>
<span class="nc" id="L1179">        f7.setTimeZone(zone);</span>

        // milliseconds
<span class="nc" id="L1182">        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 1, f1));</span>
<span class="nc" id="L1183">        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 5,</span>
<span class="nc" id="L1184">                DateTickUnitType.MILLISECOND, 1, f1));</span>
<span class="nc" id="L1185">        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 10,</span>
<span class="nc" id="L1186">                DateTickUnitType.MILLISECOND, 1, f1));</span>
<span class="nc" id="L1187">        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 25,</span>
<span class="nc" id="L1188">                DateTickUnitType.MILLISECOND, 5, f1));</span>
<span class="nc" id="L1189">        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 50,</span>
<span class="nc" id="L1190">                DateTickUnitType.MILLISECOND, 10, f1));</span>
<span class="nc" id="L1191">        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 100,</span>
<span class="nc" id="L1192">                DateTickUnitType.MILLISECOND, 10, f1));</span>
<span class="nc" id="L1193">        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 250,</span>
<span class="nc" id="L1194">                DateTickUnitType.MILLISECOND, 10, f1));</span>
<span class="nc" id="L1195">        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 500,</span>
<span class="nc" id="L1196">                DateTickUnitType.MILLISECOND, 50, f1));</span>

        // seconds
<span class="nc" id="L1199">        units.add(new DateTickUnit(DateTickUnitType.SECOND, 1,</span>
<span class="nc" id="L1200">                DateTickUnitType.MILLISECOND, 50, f2));</span>
<span class="nc" id="L1201">        units.add(new DateTickUnit(DateTickUnitType.SECOND, 5,</span>
<span class="nc" id="L1202">                DateTickUnitType.SECOND, 1, f2));</span>
<span class="nc" id="L1203">        units.add(new DateTickUnit(DateTickUnitType.SECOND, 10,</span>
<span class="nc" id="L1204">                DateTickUnitType.SECOND, 1, f2));</span>
<span class="nc" id="L1205">        units.add(new DateTickUnit(DateTickUnitType.SECOND, 30,</span>
<span class="nc" id="L1206">                DateTickUnitType.SECOND, 5, f2));</span>

        // minutes
<span class="nc" id="L1209">        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 1,</span>
<span class="nc" id="L1210">                DateTickUnitType.SECOND, 5, f3));</span>
<span class="nc" id="L1211">        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 2,</span>
<span class="nc" id="L1212">                DateTickUnitType.SECOND, 10, f3));</span>
<span class="nc" id="L1213">        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 5,</span>
<span class="nc" id="L1214">                DateTickUnitType.MINUTE, 1, f3));</span>
<span class="nc" id="L1215">        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 10,</span>
<span class="nc" id="L1216">                DateTickUnitType.MINUTE, 1, f3));</span>
<span class="nc" id="L1217">        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 15,</span>
<span class="nc" id="L1218">                DateTickUnitType.MINUTE, 5, f3));</span>
<span class="nc" id="L1219">        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 20,</span>
<span class="nc" id="L1220">                DateTickUnitType.MINUTE, 5, f3));</span>
<span class="nc" id="L1221">        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 30,</span>
<span class="nc" id="L1222">                DateTickUnitType.MINUTE, 5, f3));</span>

        // hours
<span class="nc" id="L1225">        units.add(new DateTickUnit(DateTickUnitType.HOUR, 1,</span>
<span class="nc" id="L1226">                DateTickUnitType.MINUTE, 5, f3));</span>
<span class="nc" id="L1227">        units.add(new DateTickUnit(DateTickUnitType.HOUR, 2,</span>
<span class="nc" id="L1228">                DateTickUnitType.MINUTE, 10, f3));</span>
<span class="nc" id="L1229">        units.add(new DateTickUnit(DateTickUnitType.HOUR, 4,</span>
<span class="nc" id="L1230">                DateTickUnitType.MINUTE, 30, f3));</span>
<span class="nc" id="L1231">        units.add(new DateTickUnit(DateTickUnitType.HOUR, 6,</span>
<span class="nc" id="L1232">                DateTickUnitType.HOUR, 1, f3));</span>
<span class="nc" id="L1233">        units.add(new DateTickUnit(DateTickUnitType.HOUR, 12,</span>
<span class="nc" id="L1234">                DateTickUnitType.HOUR, 1, f4));</span>

        // days
<span class="nc" id="L1237">        units.add(new DateTickUnit(DateTickUnitType.DAY, 1,</span>
<span class="nc" id="L1238">                DateTickUnitType.HOUR, 1, f5));</span>
<span class="nc" id="L1239">        units.add(new DateTickUnit(DateTickUnitType.DAY, 2,</span>
<span class="nc" id="L1240">                DateTickUnitType.HOUR, 1, f5));</span>
<span class="nc" id="L1241">        units.add(new DateTickUnit(DateTickUnitType.DAY, 7,</span>
<span class="nc" id="L1242">                DateTickUnitType.DAY, 1, f5));</span>
<span class="nc" id="L1243">        units.add(new DateTickUnit(DateTickUnitType.DAY, 15,</span>
<span class="nc" id="L1244">                DateTickUnitType.DAY, 1, f5));</span>

        // months
<span class="nc" id="L1247">        units.add(new DateTickUnit(DateTickUnitType.MONTH, 1,</span>
<span class="nc" id="L1248">                DateTickUnitType.DAY, 1, f6));</span>
<span class="nc" id="L1249">        units.add(new DateTickUnit(DateTickUnitType.MONTH, 2,</span>
<span class="nc" id="L1250">                DateTickUnitType.DAY, 1, f6));</span>
<span class="nc" id="L1251">        units.add(new DateTickUnit(DateTickUnitType.MONTH, 3,</span>
<span class="nc" id="L1252">                DateTickUnitType.MONTH, 1, f6));</span>
<span class="nc" id="L1253">        units.add(new DateTickUnit(DateTickUnitType.MONTH, 4,</span>
<span class="nc" id="L1254">                DateTickUnitType.MONTH, 1, f6));</span>
<span class="nc" id="L1255">        units.add(new DateTickUnit(DateTickUnitType.MONTH, 6,</span>
<span class="nc" id="L1256">                DateTickUnitType.MONTH, 1, f6));</span>

        // years
<span class="nc" id="L1259">        units.add(new DateTickUnit(DateTickUnitType.YEAR, 1,</span>
<span class="nc" id="L1260">                DateTickUnitType.MONTH, 1, f7));</span>
<span class="nc" id="L1261">        units.add(new DateTickUnit(DateTickUnitType.YEAR, 2,</span>
<span class="nc" id="L1262">                DateTickUnitType.MONTH, 3, f7));</span>
<span class="nc" id="L1263">        units.add(new DateTickUnit(DateTickUnitType.YEAR, 5,</span>
<span class="nc" id="L1264">                DateTickUnitType.YEAR, 1, f7));</span>
<span class="nc" id="L1265">        units.add(new DateTickUnit(DateTickUnitType.YEAR, 10,</span>
<span class="nc" id="L1266">                DateTickUnitType.YEAR, 1, f7));</span>
<span class="nc" id="L1267">        units.add(new DateTickUnit(DateTickUnitType.YEAR, 25,</span>
<span class="nc" id="L1268">                DateTickUnitType.YEAR, 5, f7));</span>
<span class="nc" id="L1269">        units.add(new DateTickUnit(DateTickUnitType.YEAR, 50,</span>
<span class="nc" id="L1270">                DateTickUnitType.YEAR, 10, f7));</span>
<span class="nc" id="L1271">        units.add(new DateTickUnit(DateTickUnitType.YEAR, 100,</span>
<span class="nc" id="L1272">                DateTickUnitType.YEAR, 20, f7));</span>

<span class="nc" id="L1274">        return units;</span>

    }

    /**
     * Rescales the axis to ensure that all data is visible.
     */
    @Override
    protected void autoAdjustRange() {

<span class="nc" id="L1284">        Plot plot = getPlot();</span>

<span class="nc bnc" id="L1286" title="All 2 branches missed.">        if (plot == null) {</span>
<span class="nc" id="L1287">            return;  // no plot, no data</span>
        }

<span class="nc bnc" id="L1290" title="All 2 branches missed.">        if (plot instanceof ValueAxisPlot) {</span>
<span class="nc" id="L1291">            ValueAxisPlot vap = (ValueAxisPlot) plot;</span>

<span class="nc" id="L1293">            Range r = vap.getDataRange(this);</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">            if (r == null) {</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                if (this.timeline instanceof SegmentedTimeline) {</span>
                    //Timeline hasn't method getStartTime()
<span class="nc" id="L1297">                    r = new DateRange((</span>
<span class="nc" id="L1298">                            (SegmentedTimeline) this.timeline).getStartTime(),</span>
<span class="nc" id="L1299">                            ((SegmentedTimeline) this.timeline).getStartTime()</span>
<span class="nc" id="L1300">                            + 1);</span>
<span class="nc" id="L1301">                }</span>
                else {
<span class="nc" id="L1303">                    r = new DateRange();</span>
                }
            }

<span class="nc" id="L1307">            long upper = this.timeline.toTimelineValue(</span>
<span class="nc" id="L1308">                    (long) r.getUpperBound());</span>
            long lower;
<span class="nc" id="L1310">            long fixedAutoRange = (long) getFixedAutoRange();</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">            if (fixedAutoRange &gt; 0.0) {</span>
<span class="nc" id="L1312">                lower = upper - fixedAutoRange;</span>
<span class="nc" id="L1313">            }</span>
            else {
<span class="nc" id="L1315">                lower = this.timeline.toTimelineValue((long) r.getLowerBound());</span>
<span class="nc" id="L1316">                double range = upper - lower;</span>
<span class="nc" id="L1317">                long minRange = (long) getAutoRangeMinimumSize();</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                if (range &lt; minRange) {</span>
<span class="nc" id="L1319">                    long expand = (long) (minRange - range) / 2;</span>
<span class="nc" id="L1320">                    upper = upper + expand;</span>
<span class="nc" id="L1321">                    lower = lower - expand;</span>
                }
<span class="nc" id="L1323">                upper = upper + (long) (range * getUpperMargin());</span>
<span class="nc" id="L1324">                lower = lower - (long) (range * getLowerMargin());</span>
            }

<span class="nc" id="L1327">            upper = this.timeline.toMillisecond(upper);</span>
<span class="nc" id="L1328">            lower = this.timeline.toMillisecond(lower);</span>
<span class="nc" id="L1329">            DateRange dr = new DateRange(new Date(lower), new Date(upper));</span>
<span class="nc" id="L1330">            setRange(dr, false, false);</span>
        }

<span class="nc" id="L1333">    }</span>

    /**
     * Selects an appropriate tick value for the axis.  The strategy is to
     * display as many ticks as possible (selected from an array of 'standard'
     * tick units) without the labels overlapping.
     *
     * @param g2  the graphics device.
     * @param dataArea  the area defined by the axes.
     * @param edge  the axis location.
     */
    protected void selectAutoTickUnit(Graphics2D g2, Rectangle2D dataArea,
            RectangleEdge edge) {

<span class="nc bnc" id="L1347" title="All 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="nc" id="L1348">            selectHorizontalAutoTickUnit(g2, dataArea, edge);</span>
<span class="nc" id="L1349">        }</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L1351">            selectVerticalAutoTickUnit(g2, dataArea, edge);</span>
        }

<span class="nc" id="L1354">    }</span>

    /**
     * Selects an appropriate tick size for the axis.  The strategy is to
     * display as many ticks as possible (selected from a collection of
     * 'standard' tick units) without the labels overlapping.
     *
     * @param g2  the graphics device.
     * @param dataArea  the area defined by the axes.
     * @param edge  the axis location.
     */
    protected void selectHorizontalAutoTickUnit(Graphics2D g2,
            Rectangle2D dataArea, RectangleEdge edge) {

<span class="nc" id="L1368">        long shift = 0;</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        if (this.timeline instanceof SegmentedTimeline) {</span>
<span class="nc" id="L1370">            shift = ((SegmentedTimeline) this.timeline).getStartTime();</span>
        }
<span class="nc" id="L1372">        double zero = valueToJava2D(shift + 0.0, dataArea, edge);</span>
<span class="nc" id="L1373">        double tickLabelWidth = estimateMaximumTickLabelWidth(g2,</span>
<span class="nc" id="L1374">                getTickUnit());</span>

        // start with the current tick unit...
<span class="nc" id="L1377">        TickUnitSource tickUnits = getStandardTickUnits();</span>
<span class="nc" id="L1378">        TickUnit unit1 = tickUnits.getCeilingTickUnit(getTickUnit());</span>
<span class="nc" id="L1379">        double x1 = valueToJava2D(shift + unit1.getSize(), dataArea, edge);</span>
<span class="nc" id="L1380">        double unit1Width = Math.abs(x1 - zero);</span>

        // then extrapolate...
<span class="nc" id="L1383">        double guess = (tickLabelWidth / unit1Width) * unit1.getSize();</span>
<span class="nc" id="L1384">        DateTickUnit unit2 = (DateTickUnit) tickUnits.getCeilingTickUnit(guess);</span>
<span class="nc" id="L1385">        double x2 = valueToJava2D(shift + unit2.getSize(), dataArea, edge);</span>
<span class="nc" id="L1386">        double unit2Width = Math.abs(x2 - zero);</span>
<span class="nc" id="L1387">        tickLabelWidth = estimateMaximumTickLabelWidth(g2, unit2);</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">        if (tickLabelWidth &gt; unit2Width) {</span>
<span class="nc" id="L1389">            unit2 = (DateTickUnit) tickUnits.getLargerTickUnit(unit2);</span>
        }
<span class="nc" id="L1391">        setTickUnit(unit2, false, false);</span>
<span class="nc" id="L1392">    }</span>

    /**
     * Selects an appropriate tick size for the axis.  The strategy is to
     * display as many ticks as possible (selected from a collection of
     * 'standard' tick units) without the labels overlapping.
     *
     * @param g2  the graphics device.
     * @param dataArea  the area in which the plot should be drawn.
     * @param edge  the axis location.
     */
    protected void selectVerticalAutoTickUnit(Graphics2D g2,
            Rectangle2D dataArea, RectangleEdge edge) {

        // start with the current tick unit...
<span class="nc" id="L1407">        TickUnitSource tickUnits = getStandardTickUnits();</span>
<span class="nc" id="L1408">        double zero = valueToJava2D(0.0, dataArea, edge);</span>

        // start with a unit that is at least 1/10th of the axis length
<span class="nc" id="L1411">        double estimate1 = getRange().getLength() / 10.0;</span>
<span class="nc" id="L1412">        DateTickUnit candidate1</span>
<span class="nc" id="L1413">            = (DateTickUnit) tickUnits.getCeilingTickUnit(estimate1);</span>
<span class="nc" id="L1414">        double labelHeight1 = estimateMaximumTickLabelHeight(g2, candidate1);</span>
<span class="nc" id="L1415">        double y1 = valueToJava2D(candidate1.getSize(), dataArea, edge);</span>
<span class="nc" id="L1416">        double candidate1UnitHeight = Math.abs(y1 - zero);</span>

        // now extrapolate based on label height and unit height...
<span class="nc" id="L1419">        double estimate2</span>
<span class="nc" id="L1420">            = (labelHeight1 / candidate1UnitHeight) * candidate1.getSize();</span>
<span class="nc" id="L1421">        DateTickUnit candidate2</span>
<span class="nc" id="L1422">            = (DateTickUnit) tickUnits.getCeilingTickUnit(estimate2);</span>
<span class="nc" id="L1423">        double labelHeight2 = estimateMaximumTickLabelHeight(g2, candidate2);</span>
<span class="nc" id="L1424">        double y2 = valueToJava2D(candidate2.getSize(), dataArea, edge);</span>
<span class="nc" id="L1425">        double unit2Height = Math.abs(y2 - zero);</span>

       // make final selection...
       DateTickUnit finalUnit;
<span class="nc bnc" id="L1429" title="All 2 branches missed.">       if (labelHeight2 &lt; unit2Height) {</span>
<span class="nc" id="L1430">           finalUnit = candidate2;</span>
<span class="nc" id="L1431">       }</span>
       else {
<span class="nc" id="L1433">           finalUnit = (DateTickUnit) tickUnits.getLargerTickUnit(candidate2);</span>
       }
<span class="nc" id="L1435">       setTickUnit(finalUnit, false, false);</span>

<span class="nc" id="L1437">    }</span>

    /**
     * Estimates the maximum width of the tick labels, assuming the specified
     * tick unit is used.
     * &lt;P&gt;
     * Rather than computing the string bounds of every tick on the axis, we
     * just look at two values: the lower bound and the upper bound for the
     * axis.  These two values will usually be representative.
     *
     * @param g2  the graphics device.
     * @param unit  the tick unit to use for calculation.
     *
     * @return The estimated maximum width of the tick labels.
     */
    private double estimateMaximumTickLabelWidth(Graphics2D g2, 
            DateTickUnit unit) {

<span class="nc" id="L1455">        RectangleInsets tickLabelInsets = getTickLabelInsets();</span>
<span class="nc" id="L1456">        double result = tickLabelInsets.getLeft() + tickLabelInsets.getRight();</span>

<span class="nc" id="L1458">        Font tickLabelFont = getTickLabelFont();</span>
<span class="nc" id="L1459">        FontRenderContext frc = g2.getFontRenderContext();</span>
<span class="nc" id="L1460">        LineMetrics lm = tickLabelFont.getLineMetrics(&quot;ABCxyz&quot;, frc);</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">        if (isVerticalTickLabels()) {</span>
            // all tick labels have the same width (equal to the height of
            // the font)...
<span class="nc" id="L1464">            result += lm.getHeight();</span>
<span class="nc" id="L1465">        }</span>
        else {
            // look at lower and upper bounds...
<span class="nc" id="L1468">            DateRange range = (DateRange) getRange();</span>
<span class="nc" id="L1469">            Date lower = range.getLowerDate();</span>
<span class="nc" id="L1470">            Date upper = range.getUpperDate();</span>
            String lowerStr, upperStr;
<span class="nc" id="L1472">            DateFormat formatter = getDateFormatOverride();</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">            if (formatter != null) {</span>
<span class="nc" id="L1474">                lowerStr = formatter.format(lower);</span>
<span class="nc" id="L1475">                upperStr = formatter.format(upper);</span>
<span class="nc" id="L1476">            }</span>
            else {
<span class="nc" id="L1478">                lowerStr = unit.dateToString(lower);</span>
<span class="nc" id="L1479">                upperStr = unit.dateToString(upper);</span>
            }
<span class="nc" id="L1481">            FontMetrics fm = g2.getFontMetrics(tickLabelFont);</span>
<span class="nc" id="L1482">            double w1 = fm.stringWidth(lowerStr);</span>
<span class="nc" id="L1483">            double w2 = fm.stringWidth(upperStr);</span>
<span class="nc" id="L1484">            result += Math.max(w1, w2);</span>
        }

<span class="nc" id="L1487">        return result;</span>

    }

    /**
     * Estimates the maximum width of the tick labels, assuming the specified
     * tick unit is used.
     * &lt;P&gt;
     * Rather than computing the string bounds of every tick on the axis, we
     * just look at two values: the lower bound and the upper bound for the
     * axis.  These two values will usually be representative.
     *
     * @param g2  the graphics device.
     * @param unit  the tick unit to use for calculation.
     *
     * @return The estimated maximum width of the tick labels.
     */
    private double estimateMaximumTickLabelHeight(Graphics2D g2,
            DateTickUnit unit) {

<span class="nc" id="L1507">        RectangleInsets tickLabelInsets = getTickLabelInsets();</span>
<span class="nc" id="L1508">        double result = tickLabelInsets.getTop() + tickLabelInsets.getBottom();</span>

<span class="nc" id="L1510">        Font tickLabelFont = getTickLabelFont();</span>
<span class="nc" id="L1511">        FontRenderContext frc = g2.getFontRenderContext();</span>
<span class="nc" id="L1512">        LineMetrics lm = tickLabelFont.getLineMetrics(&quot;ABCxyz&quot;, frc);</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        if (!isVerticalTickLabels()) {</span>
            // all tick labels have the same width (equal to the height of
            // the font)...
<span class="nc" id="L1516">            result += lm.getHeight();</span>
<span class="nc" id="L1517">        }</span>
        else {
            // look at lower and upper bounds...
<span class="nc" id="L1520">            DateRange range = (DateRange) getRange();</span>
<span class="nc" id="L1521">            Date lower = range.getLowerDate();</span>
<span class="nc" id="L1522">            Date upper = range.getUpperDate();</span>
            String lowerStr, upperStr;
<span class="nc" id="L1524">            DateFormat formatter = getDateFormatOverride();</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">            if (formatter != null) {</span>
<span class="nc" id="L1526">                lowerStr = formatter.format(lower);</span>
<span class="nc" id="L1527">                upperStr = formatter.format(upper);</span>
<span class="nc" id="L1528">            }</span>
            else {
<span class="nc" id="L1530">                lowerStr = unit.dateToString(lower);</span>
<span class="nc" id="L1531">                upperStr = unit.dateToString(upper);</span>
            }
<span class="nc" id="L1533">            FontMetrics fm = g2.getFontMetrics(tickLabelFont);</span>
<span class="nc" id="L1534">            double w1 = fm.stringWidth(lowerStr);</span>
<span class="nc" id="L1535">            double w2 = fm.stringWidth(upperStr);</span>
<span class="nc" id="L1536">            result += Math.max(w1, w2);</span>
        }

<span class="nc" id="L1539">        return result;</span>

    }

    /**
     * Calculates the positions of the tick labels for the axis, storing the
     * results in the tick label list (ready for drawing).
     *
     * @param g2  the graphics device.
     * @param state  the axis state.
     * @param dataArea  the area in which the plot should be drawn.
     * @param edge  the location of the axis.
     *
     * @return A list of ticks.
     */
    @Override
    public List refreshTicks(Graphics2D g2, AxisState state, 
            Rectangle2D dataArea, RectangleEdge edge) {

<span class="nc" id="L1558">        List result = null;</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="nc" id="L1560">            result = refreshTicksHorizontal(g2, dataArea, edge);</span>
<span class="nc" id="L1561">        }</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L1563">            result = refreshTicksVertical(g2, dataArea, edge);</span>
        }
<span class="nc" id="L1565">        return result;</span>

    }

    /**
     * Corrects the given tick date for the position setting.
     *
     * @param time  the tick date/time.
     * @param unit  the tick unit.
     * @param position  the tick position.
     *
     * @return The adjusted time.
     */
    private Date correctTickDateForPosition(Date time, DateTickUnit unit,
            DateTickMarkPosition position) {
<span class="nc" id="L1580">        Date result = time;</span>
<span class="nc bnc" id="L1581" title="All 4 branches missed.">        switch (unit.getUnit()) {</span>
            case DateTickUnit.MILLISECOND :
            case DateTickUnit.SECOND :
            case DateTickUnit.MINUTE :
            case DateTickUnit.HOUR :
            case DateTickUnit.DAY :
<span class="nc" id="L1587">                break;</span>
            case DateTickUnit.MONTH :
<span class="nc" id="L1589">                result = calculateDateForPosition(new Month(time,</span>
<span class="nc" id="L1590">                        this.timeZone, this.locale), position);</span>
<span class="nc" id="L1591">                break;</span>
            case DateTickUnit.YEAR :
<span class="nc" id="L1593">                result = calculateDateForPosition(new Year(time,</span>
<span class="nc" id="L1594">                        this.timeZone, this.locale), position);</span>
<span class="nc" id="L1595">                break;</span>

            default: break;
        }
<span class="nc" id="L1599">        return result;</span>
    }

    /**
     * Recalculates the ticks for the date axis.
     *
     * @param g2  the graphics device.
     * @param dataArea  the area in which the data is to be drawn.
     * @param edge  the location of the axis.
     *
     * @return A list of ticks.
     */
    protected List refreshTicksHorizontal(Graphics2D g2,
                Rectangle2D dataArea, RectangleEdge edge) {

<span class="nc" id="L1614">        List result = new java.util.ArrayList();</span>

<span class="nc" id="L1616">        Font tickLabelFont = getTickLabelFont();</span>
<span class="nc" id="L1617">        g2.setFont(tickLabelFont);</span>

<span class="nc bnc" id="L1619" title="All 2 branches missed.">        if (isAutoTickUnitSelection()) {</span>
<span class="nc" id="L1620">            selectAutoTickUnit(g2, dataArea, edge);</span>
        }

<span class="nc" id="L1623">        DateTickUnit unit = getTickUnit();</span>
<span class="nc" id="L1624">        Date tickDate = calculateLowestVisibleTickValue(unit);</span>
<span class="nc" id="L1625">        Date upperDate = getMaximumDate();</span>

<span class="nc" id="L1627">        boolean hasRolled = false;</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">        while (tickDate.before(upperDate)) {</span>
            // could add a flag to make the following correction optional...
<span class="nc bnc" id="L1630" title="All 2 branches missed.">            if (!hasRolled) {</span>
<span class="nc" id="L1631">                tickDate = correctTickDateForPosition(tickDate, unit,</span>
<span class="nc" id="L1632">                     this.tickMarkPosition);</span>
            }

<span class="nc" id="L1635">            long lowestTickTime = tickDate.getTime();</span>
<span class="nc" id="L1636">            long distance = unit.addToDate(tickDate, this.timeZone).getTime()</span>
<span class="nc" id="L1637">                    - lowestTickTime;</span>
<span class="nc" id="L1638">            int minorTickSpaces = getMinorTickCount();</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">            if (minorTickSpaces &lt;= 0) {</span>
<span class="nc" id="L1640">                minorTickSpaces = unit.getMinorTickCount();</span>
            }
<span class="nc bnc" id="L1642" title="All 2 branches missed.">            for (int minorTick = 1; minorTick &lt; minorTickSpaces; minorTick++) {</span>
<span class="nc" id="L1643">                long minorTickTime = lowestTickTime - distance</span>
<span class="nc" id="L1644">                        * minorTick / minorTickSpaces;</span>
<span class="nc bnc" id="L1645" title="All 4 branches missed.">                if (minorTickTime &gt; 0 &amp;&amp; getRange().contains(minorTickTime)</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">                        &amp;&amp; (!isHiddenValue(minorTickTime))) {</span>
<span class="nc" id="L1647">                    result.add(new DateTick(TickType.MINOR,</span>
<span class="nc" id="L1648">                            new Date(minorTickTime), &quot;&quot;, TextAnchor.TOP_CENTER,</span>
<span class="nc" id="L1649">                            TextAnchor.CENTER, 0.0));</span>
                }
            }

<span class="nc bnc" id="L1653" title="All 2 branches missed.">            if (!isHiddenValue(tickDate.getTime())) {</span>
                // work out the value, label and position
                String tickLabel;
<span class="nc" id="L1656">                DateFormat formatter = getDateFormatOverride();</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">                if (formatter != null) {</span>
<span class="nc" id="L1658">                    tickLabel = formatter.format(tickDate);</span>
<span class="nc" id="L1659">                }</span>
                else {
<span class="nc" id="L1661">                    tickLabel = this.tickUnit.dateToString(tickDate);</span>
                }
                TextAnchor anchor, rotationAnchor;
<span class="nc" id="L1664">                double angle = 0.0;</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">                if (isVerticalTickLabels()) {</span>
<span class="nc" id="L1666">                    anchor = TextAnchor.CENTER_RIGHT;</span>
<span class="nc" id="L1667">                    rotationAnchor = TextAnchor.CENTER_RIGHT;</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">                    if (edge == RectangleEdge.TOP) {</span>
<span class="nc" id="L1669">                        angle = Math.PI / 2.0;</span>
<span class="nc" id="L1670">                    }</span>
                    else {
<span class="nc" id="L1672">                        angle = -Math.PI / 2.0;</span>
                    }
<span class="nc" id="L1674">                }</span>
                else {
<span class="nc bnc" id="L1676" title="All 2 branches missed.">                    if (edge == RectangleEdge.TOP) {</span>
<span class="nc" id="L1677">                        anchor = TextAnchor.BOTTOM_CENTER;</span>
<span class="nc" id="L1678">                        rotationAnchor = TextAnchor.BOTTOM_CENTER;</span>
<span class="nc" id="L1679">                    }</span>
                    else {
<span class="nc" id="L1681">                        anchor = TextAnchor.TOP_CENTER;</span>
<span class="nc" id="L1682">                        rotationAnchor = TextAnchor.TOP_CENTER;</span>
                    }
                }

<span class="nc" id="L1686">                Tick tick = new DateTick(tickDate, tickLabel, anchor,</span>
<span class="nc" id="L1687">                        rotationAnchor, angle);</span>
<span class="nc" id="L1688">                result.add(tick);</span>
<span class="nc" id="L1689">                hasRolled = false;</span>

<span class="nc" id="L1691">                long currentTickTime = tickDate.getTime();</span>
<span class="nc" id="L1692">                tickDate = unit.addToDate(tickDate, this.timeZone);</span>
<span class="nc" id="L1693">                long nextTickTime = tickDate.getTime();</span>
<span class="nc bnc" id="L1694" title="All 2 branches missed.">                for (int minorTick = 1; minorTick &lt; minorTickSpaces;</span>
<span class="nc" id="L1695">                        minorTick++) {</span>
<span class="nc" id="L1696">                    long minorTickTime = currentTickTime</span>
<span class="nc" id="L1697">                            + (nextTickTime - currentTickTime)</span>
<span class="nc" id="L1698">                            * minorTick / minorTickSpaces;</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">                    if (getRange().contains(minorTickTime)</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">                            &amp;&amp; (!isHiddenValue(minorTickTime))) {</span>
<span class="nc" id="L1701">                        result.add(new DateTick(TickType.MINOR,</span>
<span class="nc" id="L1702">                                new Date(minorTickTime), &quot;&quot;,</span>
<span class="nc" id="L1703">                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,</span>
<span class="nc" id="L1704">                                0.0));</span>
                    }
                }

<span class="nc" id="L1708">            }</span>
            else {
<span class="nc" id="L1710">                tickDate = unit.rollDate(tickDate, this.timeZone);</span>
<span class="nc" id="L1711">                hasRolled = true;</span>
                continue;
            }

        }
<span class="nc" id="L1716">        return result;</span>

    }

    /**
     * Recalculates the ticks for the date axis.
     *
     * @param g2  the graphics device.
     * @param dataArea  the area in which the plot should be drawn.
     * @param edge  the location of the axis.
     *
     * @return A list of ticks.
     */
    protected List refreshTicksVertical(Graphics2D g2,
            Rectangle2D dataArea, RectangleEdge edge) {

<span class="nc" id="L1732">        List result = new java.util.ArrayList();</span>

<span class="nc" id="L1734">        Font tickLabelFont = getTickLabelFont();</span>
<span class="nc" id="L1735">        g2.setFont(tickLabelFont);</span>

<span class="nc bnc" id="L1737" title="All 2 branches missed.">        if (isAutoTickUnitSelection()) {</span>
<span class="nc" id="L1738">            selectAutoTickUnit(g2, dataArea, edge);</span>
        }
<span class="nc" id="L1740">        DateTickUnit unit = getTickUnit();</span>
<span class="nc" id="L1741">        Date tickDate = calculateLowestVisibleTickValue(unit);</span>
<span class="nc" id="L1742">        Date upperDate = getMaximumDate();</span>

<span class="nc" id="L1744">        boolean hasRolled = false;</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">        while (tickDate.before(upperDate)) {</span>

            // could add a flag to make the following correction optional...
<span class="nc bnc" id="L1748" title="All 2 branches missed.">            if (!hasRolled) {</span>
<span class="nc" id="L1749">                tickDate = correctTickDateForPosition(tickDate, unit,</span>
<span class="nc" id="L1750">                    this.tickMarkPosition);</span>
            }

<span class="nc" id="L1753">            long lowestTickTime = tickDate.getTime();</span>
<span class="nc" id="L1754">            long distance = unit.addToDate(tickDate, this.timeZone).getTime()</span>
<span class="nc" id="L1755">                    - lowestTickTime;</span>
<span class="nc" id="L1756">            int minorTickSpaces = getMinorTickCount();</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">            if (minorTickSpaces &lt;= 0) {</span>
<span class="nc" id="L1758">                minorTickSpaces = unit.getMinorTickCount();</span>
            }
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            for (int minorTick = 1; minorTick &lt; minorTickSpaces; minorTick++) {</span>
<span class="nc" id="L1761">                long minorTickTime = lowestTickTime - distance</span>
<span class="nc" id="L1762">                        * minorTick / minorTickSpaces;</span>
<span class="nc bnc" id="L1763" title="All 4 branches missed.">                if (minorTickTime &gt; 0 &amp;&amp; getRange().contains(minorTickTime)</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">                        &amp;&amp; (!isHiddenValue(minorTickTime))) {</span>
<span class="nc" id="L1765">                    result.add(new DateTick(TickType.MINOR,</span>
<span class="nc" id="L1766">                            new Date(minorTickTime), &quot;&quot;, TextAnchor.TOP_CENTER,</span>
<span class="nc" id="L1767">                            TextAnchor.CENTER, 0.0));</span>
                }
            }
<span class="nc bnc" id="L1770" title="All 2 branches missed.">            if (!isHiddenValue(tickDate.getTime())) {</span>
                // work out the value, label and position
                String tickLabel;
<span class="nc" id="L1773">                DateFormat formatter = getDateFormatOverride();</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">                if (formatter != null) {</span>
<span class="nc" id="L1775">                    tickLabel = formatter.format(tickDate);</span>
<span class="nc" id="L1776">                }</span>
                else {
<span class="nc" id="L1778">                    tickLabel = this.tickUnit.dateToString(tickDate);</span>
                }
                TextAnchor anchor, rotationAnchor;
<span class="nc" id="L1781">                double angle = 0.0;</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">                if (isVerticalTickLabels()) {</span>
<span class="nc" id="L1783">                    anchor = TextAnchor.BOTTOM_CENTER;</span>
<span class="nc" id="L1784">                    rotationAnchor = TextAnchor.BOTTOM_CENTER;</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">                    if (edge == RectangleEdge.LEFT) {</span>
<span class="nc" id="L1786">                        angle = -Math.PI / 2.0;</span>
<span class="nc" id="L1787">                    }</span>
                    else {
<span class="nc" id="L1789">                        angle = Math.PI / 2.0;</span>
                    }
<span class="nc" id="L1791">                }</span>
                else {
<span class="nc bnc" id="L1793" title="All 2 branches missed.">                    if (edge == RectangleEdge.LEFT) {</span>
<span class="nc" id="L1794">                        anchor = TextAnchor.CENTER_RIGHT;</span>
<span class="nc" id="L1795">                        rotationAnchor = TextAnchor.CENTER_RIGHT;</span>
<span class="nc" id="L1796">                    }</span>
                    else {
<span class="nc" id="L1798">                        anchor = TextAnchor.CENTER_LEFT;</span>
<span class="nc" id="L1799">                        rotationAnchor = TextAnchor.CENTER_LEFT;</span>
                    }
                }

<span class="nc" id="L1803">                Tick tick = new DateTick(tickDate, tickLabel, anchor,</span>
<span class="nc" id="L1804">                        rotationAnchor, angle);</span>
<span class="nc" id="L1805">                result.add(tick);</span>
<span class="nc" id="L1806">                hasRolled = false;</span>

<span class="nc" id="L1808">                long currentTickTime = tickDate.getTime();</span>
<span class="nc" id="L1809">                tickDate = unit.addToDate(tickDate, this.timeZone);</span>
<span class="nc" id="L1810">                long nextTickTime = tickDate.getTime();</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">                for (int minorTick = 1; minorTick &lt; minorTickSpaces;</span>
<span class="nc" id="L1812">                        minorTick++) {</span>
<span class="nc" id="L1813">                    long minorTickTime = currentTickTime</span>
<span class="nc" id="L1814">                            + (nextTickTime - currentTickTime)</span>
<span class="nc" id="L1815">                            * minorTick / minorTickSpaces;</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">                    if (getRange().contains(minorTickTime)</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">                            &amp;&amp; (!isHiddenValue(minorTickTime))) {</span>
<span class="nc" id="L1818">                        result.add(new DateTick(TickType.MINOR,</span>
<span class="nc" id="L1819">                                new Date(minorTickTime), &quot;&quot;,</span>
<span class="nc" id="L1820">                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,</span>
<span class="nc" id="L1821">                                0.0));</span>
                    }
                }
<span class="nc" id="L1824">            }</span>
            else {
<span class="nc" id="L1826">                tickDate = unit.rollDate(tickDate, this.timeZone);</span>
<span class="nc" id="L1827">                hasRolled = true;</span>
            }
        }
<span class="nc" id="L1830">        return result;</span>
    }

    /**
     * Draws the axis on a Java 2D graphics device (such as the screen or a
     * printer).
     *
     * @param g2  the graphics device (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param cursor  the cursor location.
     * @param plotArea  the area within which the axes and data should be
     *                  drawn (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param dataArea  the area within which the data should be drawn
     *                  (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param edge  the location of the axis (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param plotState  collects information about the plot
     *                   (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @return The axis state (never &lt;code&gt;null&lt;/code&gt;).
     */
    @Override
    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,
            Rectangle2D dataArea, RectangleEdge edge,
            PlotRenderingInfo plotState) {

        // if the axis is not visible, don't draw it...
<span class="nc bnc" id="L1855" title="All 2 branches missed.">        if (!isVisible()) {</span>
<span class="nc" id="L1856">            AxisState state = new AxisState(cursor);</span>
            // even though the axis is not visible, we need to refresh ticks in
            // case the grid is being drawn...
<span class="nc" id="L1859">            List ticks = refreshTicks(g2, state, dataArea, edge);</span>
<span class="nc" id="L1860">            state.setTicks(ticks);</span>
<span class="nc" id="L1861">            return state;</span>
        }

        // draw the tick marks and labels...
<span class="nc" id="L1865">        AxisState state = drawTickMarksAndLabels(g2, cursor, plotArea,</span>
<span class="nc" id="L1866">                dataArea, edge);</span>

        // draw the axis label (note that 'state' is passed in *and*
        // returned)...
<span class="nc bnc" id="L1870" title="All 2 branches missed.">        if (getAttributedLabel() != null) {</span>
<span class="nc" id="L1871">            state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, </span>
<span class="nc" id="L1872">                    dataArea, edge, state);</span>
            
<span class="nc" id="L1874">        } else {</span>
<span class="nc" id="L1875">            state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);</span>
        }
<span class="nc" id="L1877">        createAndAddEntity(cursor, state, dataArea, edge, plotState);</span>
<span class="nc" id="L1878">        return state;</span>

    }

    /**
     * Zooms in on the current range (zoom-in stops once the axis length 
     * reaches the equivalent of one millisecond).  
     *
     * @param lowerPercent  the new lower bound.
     * @param upperPercent  the new upper bound.
     */
    @Override
    public void zoomRange(double lowerPercent, double upperPercent) {
<span class="nc" id="L1891">        double start = this.timeline.toTimelineValue(</span>
<span class="nc" id="L1892">                (long) getRange().getLowerBound());</span>
<span class="nc" id="L1893">        double end = this.timeline.toTimelineValue(</span>
<span class="nc" id="L1894">                (long) getRange().getUpperBound());</span>
<span class="nc" id="L1895">        double length = end - start;</span>
        Range adjusted;
        long adjStart, adjEnd;
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        if (isInverted()) {</span>
<span class="nc" id="L1899">            adjStart = (long) (start + (length * (1 - upperPercent)));</span>
<span class="nc" id="L1900">            adjEnd = (long) (start + (length * (1 - lowerPercent)));</span>
<span class="nc" id="L1901">        }</span>
        else {
<span class="nc" id="L1903">            adjStart = (long) (start + length * lowerPercent);</span>
<span class="nc" id="L1904">            adjEnd = (long) (start + length * upperPercent);</span>
        }
        // when zooming to sub-millisecond ranges, it can be the case that
        // adjEnd == adjStart...and we can't have an axis with zero length
        // so we apply this instead:
<span class="nc bnc" id="L1909" title="All 2 branches missed.">        if (adjEnd &lt;= adjStart) {</span>
<span class="nc" id="L1910">            adjEnd = adjStart + 1L;</span>
        } 
<span class="nc" id="L1912">        adjusted = new DateRange(this.timeline.toMillisecond(adjStart),</span>
<span class="nc" id="L1913">               this.timeline.toMillisecond(adjEnd));</span>
<span class="nc" id="L1914">        setRange(adjusted);</span>
<span class="nc" id="L1915">    }</span>

    /**
     * Tests this axis for equality with an arbitrary object.
     *
     * @param obj  the object (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @return A boolean.
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L1926" title="All 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L1927">            return true;</span>
        }
<span class="nc bnc" id="L1929" title="All 2 branches missed.">        if (!(obj instanceof DateAxis)) {</span>
<span class="nc" id="L1930">            return false;</span>
        }
<span class="nc" id="L1932">        DateAxis that = (DateAxis) obj;</span>
<span class="nc bnc" id="L1933" title="All 2 branches missed.">        if (!ObjectUtilities.equal(this.timeZone, that.timeZone)) {</span>
<span class="nc" id="L1934">            return false;</span>
        }
<span class="nc bnc" id="L1936" title="All 2 branches missed.">        if (!ObjectUtilities.equal(this.locale, that.locale)) {</span>
<span class="nc" id="L1937">            return false;</span>
        }
<span class="nc bnc" id="L1939" title="All 2 branches missed.">        if (!ObjectUtilities.equal(this.tickUnit, that.tickUnit)) {</span>
<span class="nc" id="L1940">            return false;</span>
        }
<span class="nc" id="L1942">        if (!ObjectUtilities.equal(this.dateFormatOverride,</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">                that.dateFormatOverride)) {</span>
<span class="nc" id="L1944">            return false;</span>
        }
<span class="nc" id="L1946">        if (!ObjectUtilities.equal(this.tickMarkPosition,</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">                that.tickMarkPosition)) {</span>
<span class="nc" id="L1948">            return false;</span>
        }
<span class="nc bnc" id="L1950" title="All 2 branches missed.">        if (!ObjectUtilities.equal(this.timeline, that.timeline)) {</span>
<span class="nc" id="L1951">            return false;</span>
        }
<span class="nc" id="L1953">        return super.equals(obj);</span>
    }

    /**
     * Returns a hash code for this object.
     *
     * @return A hash code.
     */
    @Override
    public int hashCode() {
<span class="nc" id="L1963">        return super.hashCode();</span>
    }

    /**
     * Returns a clone of the object.
     *
     * @return A clone.
     *
     * @throws CloneNotSupportedException if some component of the axis does
     *         not support cloning.
     */
    @Override
    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L1976">        DateAxis clone = (DateAxis) super.clone();</span>
        // 'dateTickUnit' is immutable : no need to clone
<span class="nc bnc" id="L1978" title="All 2 branches missed.">        if (this.dateFormatOverride != null) {</span>
<span class="nc" id="L1979">            clone.dateFormatOverride</span>
<span class="nc" id="L1980">                = (DateFormat) this.dateFormatOverride.clone();</span>
        }
        // 'tickMarkPosition' is immutable : no need to clone
<span class="nc" id="L1983">        return clone;</span>
    }
 
    /**
     * Returns a collection of standard date tick units.  This collection will
     * be used by default, but you are free to create your own collection if
     * you want to (see the
     * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited
     * from the {@link ValueAxis} class).
     *
     * @param zone  the time zone (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return A collection of standard date tick units.
     *
     * @deprecated Since 1.0.11, use {@link #createStandardDateTickUnits(
     *         TimeZone, Locale)} to explicitly set the locale as well as the
     *         time zone.
     */
    public static TickUnitSource createStandardDateTickUnits(TimeZone zone) {
<span class="nc" id="L2002">        return createStandardDateTickUnits(zone, Locale.getDefault());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span>org.jfree.data (Mar 14, 2025 10:05:31â€¯p.m.)</div></body></html>